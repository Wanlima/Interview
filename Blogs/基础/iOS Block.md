###Block本质> 封装了函数调用以及函数调用环境的**OC对象**。###Block类型#### Global:> 全局Block，全局静态变量、全局变量、局部静态变量、不访问外部变量。````int main(int argc, char * argv[]) {    void(^global)(void) = ^() {        NSLog(@"这是一个全局Block！");    };    NSLog(@"%@", global);    NSString * appDelegateClassName;    @autoreleasepool {        // Setup code that might create autoreleased objects goes here.        appDelegateClassName = NSStringFromClass([AppDelegate class]);    }    return UIApplicationMain(argc, argv, nil, appDelegateClassName);}````打印信息：````$ <__NSGlobalBlock__: 0x1009c4038>````#### Stack:> 访问局部变量。先把main.m改为MRC，因为ARC会帮助我们做很多事情，可能会影响我们的观察:> `Targets` -> `Build Phases` 选项下 `Compile Sources` 下选择 `main.m`，双击，输入 `-fno-objc-arc`。````int main(int argc, char * argv[]) {    int d = 40;    void(^stack)(int, int) = ^(int a, int b) {        NSLog(@"%d", a+b);        NSLog(@"%d", d);    };    NSLog(@"%@", stack);    NSString * appDelegateClassName;    @autoreleasepool {        // Setup code that might create autoreleased objects goes here.        appDelegateClassName = NSStringFromClass([AppDelegate class]);    }    return UIApplicationMain(argc, argv, nil, appDelegateClassName);}````打印信息：````$ <__NSStackBlock__: 0x16f443840>````#### Malloc:对栈区Block拷贝：````int main(int argc, char * argv[]) {        int d = 40;    void(^stack)(int, int) = ^(int a, int b) {        NSLog(@"%d", a+b);        NSLog(@"%d", d);    };    NSLog(@"%@", stack);    void(^malloc)(int, int) = [stack copy];    NSLog(@"%@", malloc);    NSString * appDelegateClassName;    @autoreleasepool {        // Setup code that might create autoreleased objects goes here.        appDelegateClassName = NSStringFromClass([AppDelegate class]);    }    return UIApplicationMain(argc, argv, nil, appDelegateClassName);}````打印信息：````$ <__NSStackBlock__: 0x16b3af840>$ <__NSMallocBlock__: 0x282657540>````> 栈上的Block，如果其所属的变量作用域结束，该Block就被废弃，如同一般的自动变量。因此， ARC 下Block访问外部变量、函数返回Block，编译器会恰当地进行判断是否有需要copy到堆上。例如下面函数返回值为Block类型的函数： ````typedef int (^blk_t)(int);blk_t func(int rate) {    return ^(int count) { return rate * count; };}````       分析可知：上面的函数返回的Block是配置在栈上的，所以返回函数调用方时，Block变量作用域就结束了，Block会被废弃。但在ARC有效，这种情况编译器会自动完成复制。在MRC情况下则需要开发者调用copy方法手动复制，否则会报错：`Returning block that lives on the local stack`。由于开发中几乎都是ARC模式，所以手动复制内容不再过多研究。###Block捕获外界变量：1. **值拷贝：局部变量、auto自动变量（离开作用域就销毁）；**2. **指针引用：Static静态变量、OC对象；**3. **全局变量任何地方都能访问，不需要捕获；**###__block做了什么?使用命令行将代码转化为C++查看其内部结构，与OC代码进行比较````xcrun -sdk iphoneos clang -arch arm64 -framework UIKit -rewrite-objc -fobjc-arc -fobjc-runtime=ios-9.0.0 main.m -o main.cpp````不加__block修饰外部变量：````int d = 40;void(^block)(void) = ^{    NSLog(@"%d", d);};d++;block();````C++代码：````// block 结构体struct __main_block_impl_0 {  struct __block_impl impl;  struct __main_block_desc_0* Desc;  int d;  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _d, int flags=0) : d(_d) {    impl.isa = &_NSConcreteStackBlock;    impl.Flags = flags;    impl.FuncPtr = fp;    Desc = desc;  }};// 代码块static void __main_block_func_0(struct __main_block_impl_0 *__cself) {  int d = __cself->d; // bound by copy  NSLog((NSString *)&__NSConstantStringImpl__var_folders____bsyl0rc97dj3tgk7r520cy880000gn_T_main_f88f53_mi_0, d);}int d = 40;// block 声明void(*block)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, d));d++;// block();((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);````加__block修饰外部变量：````__block int d = 40;void(^block)(void) = ^{    NSLog(@"%d", d);};d++;block();````C++代码：````// __block 生成的结构体struct __Block_byref_d_0 {  void *__isa;  __Block_byref_d_0 *__forwarding; int __flags; int __size; int d;};// block 结构体struct __main_block_impl_0 {  struct __block_impl impl;  struct __main_block_desc_0* Desc;  __Block_byref_d_0 *d; // by ref  __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_d_0 *_d, int flags=0) : d(_d->__forwarding) {    impl.isa = &_NSConcreteStackBlock;    impl.Flags = flags;    impl.FuncPtr = fp;    Desc = desc;  }};// 代码块（d->__forwarding->d）static void __main_block_func_0(struct __main_block_impl_0 *__cself) {  __Block_byref_d_0 *d = __cself->d; // bound by ref  NSLog((NSString *)&__NSConstantStringImpl__var_folders____bsyl0rc97dj3tgk7r520cy880000gn_T_main_585285_mi_0, (d->__forwarding->d));}// __block int d = 40;__attribute__((__blocks__(byref))) __Block_byref_d_0 d = {(void*)0,(__Block_byref_d_0 *)&d, 0, sizeof(__Block_byref_d_0), 40};// block 声明void(*block)(void) = ((void (*)())&__main_block_impl_0((void *)__main_block_func_0, &__main_block_desc_0_DATA, (__Block_byref_d_0 *)&d, 570425344));//d++;(d.__forwarding->d)++;// block();((void (*)(__block_impl *))((__block_impl *)block)->FuncPtr)((__block_impl *)block);````总结：1. **__block** 会生成 **\_\_Block_byref\_d\_0** 结构体，block结构体会持有它；2. 外部修改变量时，会通过 **d.__forwarding->d** 改变 **\_\_Block_byref\_d\_0** 结构体中的值；3. 在代码块调用时，会通过block结构体持有的指针， **d.__forwarding->d** 获取变量的值；